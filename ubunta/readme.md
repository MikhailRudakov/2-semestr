https://docs.google.com/document/d/1z27O5xLblWKjIxcXRZnbd1smm-oYa8bt/edit

История ОС
ОС ЭВМ 1 поколения пока не существует

1943г Баллистические таблицы
Расчет 4 года Джон Мокли и Джон Эккерт разработали первый компьютер ЭНИАК(Electronic Numerical Integrator and Computer). Первый электронный дифференциальный анализатор. Вместо механических анализаторов использовали лампы. Скорость одного расчета - 5 минут. Для перепрограммирования используются перемычки. Делалось вручную. Данные на перфокарте. Каждая подавалась по одной, ее заполняли вручную. Десятичные счисления.

Архитектура Фон Неймана
Переход к двоичной системе(1 - сигнал, 0 - нет сигнала).
Появления памяти. Командные данные хранятся в памяти. Память - пронумерованные ячейки. Она имеет адрес, процессор имеет доступ к ячейке по ней. Программа - последовательные команды.
ЭВМ 2 поколения
Появление языков программирования. В 50е годы появились транзисторы. Преимущества перед лампами:

Надежность
Размер
Не выделяют тепло
Высокая скорость переключения
Плотная компоновка деталей Недостатки:
Стоимость
Сложный ремонт
Шум Появились алгоритмические языки (cobol, algol) и компиляторы. Теперь есть возможность давать несколько заданий.
ЭВМ 3 поколения
Проблемы:

Полупроводник не размещает на себе элементы. Решение - использование фотолитографии.
Изоляция элементов друг от друга. Решение - фотолитографии.
Объединение элементов. Решение - напыление алюминия. Особенность фотолитографии - автоматическое производство > удешевление. 60-70г Увеличение надежности, ускорение ввода за счет магнитных лент. Особенность магнитного диска - произвольный доступ. Появляется мультипрограммирование. Запуск программ параллельно.
ЭВМ 4 поколения
Существует виртуальная память. Подгружается только часть выполняемой программы. 1969 Деннис Макалистэйр Ритчи И Кен Томпсон разработали Unix 1978 BSD сетевое взаимодействие, виртуальная страничная память. TCP/IP. Файловая система FFS(UFS). Идеология UNIX:

Писать те программы, которые делают что-то одно и делают это хорошо.
Объединить несколько программ.
Поддержка текстовых потоков.
Функции ОС:

Выполнение программ
Выдление памяти
Редактироание файлов
Управление паматью системы
Доступ к устройствам ввода/вывода.
Монолитное ядро
Это классическая и, на сегодня, наиболее распространённая архитектура ядер операционных систем. Монолитные ядра предоставляют богатый набор абстракций оборудования. Все части монолитного ядра работают в одном адресном пространстве. Особенность - все части монолитного ядра работают в одном адресном пространстве.

Совместимость ОС - двоичное и на уровне исходных кодов. В UNIX выделены основные типы файлов:

Символьные устройства.
Блочные устройства.
Каталоги.
Ссылки.
Именованные каналы.
Сокеты
Коммандная строка
документацию можно прочитать, введя --help

Документация состоит из разделов

1. исполняемые программы

2. функции

3. библиотечные функции

4. специальные файлы

5. форматы файлов

6. игры

7. разное (макросы и соглашения)

8. комманды администрирования

9. процедуры ядра

Редатирование файлов
less - постраничный просмотр и поиск

file, stst - информация о файле

readlink - получить полное имя файла

tail, head - просмотр конца и начала файла. Монитор логов

vi/vim, emacs, nano, mcedit - редактирование текста

split - разбить файл на несколько частей

Файлы
touch - создаёт файл, если он не существует

cp - копирование

mv - перемещение/переименование файла

ln - создаёт ссылки на файлы

alias - создаёт алиас для команды

Удаление файлов
cd - переход в указанную директорию: . - текущая; .. - дир одним уровнем иерархии выше

cd - - переходв предыдущую использованную директорию

ls - отображает содержимое директории

pwd - отображает текущую директорию

readlink - полный путь к файлу

Права файлов
-rwx

- обыйный файл, d директория, l ссылки, s сокеты, r чтение, w запись, x исполнение

Кто и икогда
w - показывает, кто залогинен и чем занят

whe - показывает, кто залогинен

wall - отправляет сообщение на все терминалы

useradd - утилита создания пользователя

userdel - утилита удаление пользователя

usermod - у изменения аккаунтов

date - просмотр, установленной даты

cal, ncal - простой календарь

Потоки ввода/вывода
STDIN(0) - стандартный ввод

STDOUT(1) - стандартный вывод

STDERR(2) - стандартный поток ошибок

< - перенаправление ввода с клавиатуры в файл

> - перенаправление вывода с файла в командную строку

Процессы
Процесс - обстрак.термин. Под ним понимаетмя набор ресурсов задачи во время выполнения.

1)Память 2)Дискриптор 3)Контекс выполнения 4)pid 5)обработчики сигналов 6)один поток, как минимум.
Потоки имеют
1)обш.вир.память

2) каждый свой вирт.процессор

Stack - Адреса возврата из подпрограмм(Аргументы функций)

mmap - Разделяемая библиотека

неиспользованная память

heap - Всякие локальные переменные и временные данные

bss - Неинициализированные и статические переменные

data - Иницициализированные и статические переменные

text - исполняемые инструкции (код)

Стек - переполнение чего-то там.

Виртуальная файловая система /proc

Pid/maps - карта памяти

Pid/fd - откр.файловые дескрипторы

Pid/enivorm - переменые окружения

Pid/exe - симлик на использ.файл

Pid/cwd симлик на деректорию

Pid/status состояние процессора.

Жизненный цикл процесса
Появление процесса в системе

Init - 1й процесс в системе
функ.fork() - порождет новый процесс со всеми его атрибутами и ресурсами(сист.вызова clone())
После вызова fork() и дочерний и родительский процессы продолжают работу с точки вызова fork()
Дочернему процессу Fork() возвращает 0, родительскому - PID порожденного процесса.
Дочерний процесс - полная копия родительского, за исключением PID.
Первым управление получает child
Процесс и поток для ядра linux - одинаковые сущности.
Поток отличается только наличием разделяемых ресурсов.
(Copy-on-write) Адресное пространство родителя и порожденного процесса совместное Дубликат ресурсов создается только при попытке изменить данные Для создания потока используется тот же системный вызов clone()

Новый процесс: exec
Exec загружает бинарный файл в адресное пространство процесса
выполнение начинается с точки входа в программу
при выполнении сразу после fork() копирования страниц памяти и происходит

image

(Смерть процесса)

Процесс заканчивается системным вызовом exit() либо сигналом завершения
Сигнал процессу можно отправить командой kill
После завершения дочерний процесс находитс в состоянии зомби
Если род.процесс завершился раньше дочернего родительским становится либо другой потом
(Состояния процесса: Ready)

(R) процесс готов к выполнению
Ждет выделения процессорного времени планировщиком в очереди
Среднюю очередь ожидающих процессор процессов показывает Load average
(Состояние процесса: Остановлен)

Остановлен - процесс прекращает работу до получение сигнала SIGCONT
Используют транссировщики
Сочетание клавишь CTRL+Z или сигнал SIGSTOP отправляет процесс в это состояние
(Состояние процесса: Sleeping)

Sleeping - процесс ожидании
Вызов функции sleep() отправляет процесс в состоянии S
Как только ресурс доступен - процесс переходит в состояние READY или Running image
Устройства
2 типа устройств:

Символьные (клавиатура, мышь - ввод/вывод) - последовательный поток данных - байт за байтом. Имеют только одну позицию - текущая. нельзя обратиться к случ данным
Блочные (hdd, флешки, ssd и тд.) - можно обращаться к данным случ образом. имеют доступ к любому адресу в устройстве. чувствительны к производительности Имеют сектор и блок. Сектор - наименьший адресуемый элемент блочного устройства. (у-во не может работать с элементом данных меньше чем сектор) раньше - 512 б. сейчас - 4кб. Блок - используется для ядра и ПО. блок совпадает с размером сектора. размер блока не больше размера страницы памяти
Очередь запросов.
Файловая система отправляет запросы к у-ву в очередь. очередь содержит информацию на ввод/вывод и управляющую информацию.

Файловые системы.
Это способ отображения физ данных в файлы. Задачи:

отображение логического представления
реализация интерфейса и доступа к файлам
упорядочивание файлов
защита данных при сбоях
реализация контроля доступа к файлам
Иерархия файловой системы
В windows начинается с названия локального диска В linux представляет единое дерево

/ - корень файловой системы /boot - файлы загрузчика и ядро /etc - конф. файлы /usr, /usr/local - программы пользователя /bin, /usr/bin - исполняемый файлы /home - домашние каталоги пользователей

Абсолютные и относительные пути к файлы
Асболютный - путь от корня файловой системы Отностительный - путь от некорневого каталога

Относительный путей к одному файлу может быть бесконечное множество Одному файлу соответствует только один абсолютный путь

inode - уникальный номер файла. содержатся метаданные файла. Содержит:

Типа файлы, атрибуты и права доступа - regular (-), директории (d), ссылки (l) - мягкие и жесткие, сокеты (s) не передает данные, каналы (p) передает, символьные - (char), блочные (block)
id владельца и группы
Число ссылок на файл
Массив адресов блоков файла
Время доступа к файлу
Не содержит:

Имя файла
Данные файла
Прерывание. Планировщик процессов
Сигналы - способ оповестить процесс о событии. использутся для управления процессами. Каждый сигнал имеет обработчик сигнала по умолчанию и действие по умолчанию Можно переопределить (используется редко) Сигналы можно игнорировать, кроме SIGKILL, SIGSTOP

Прерывания - события, требующие немедленной реакции со стороны процесса. Аппаратные - поступают от устройства в любое время Программные - поступают при выполнении программ, системные Маскируемые/Немаскируемые

Синхронные прерывания (исключения)
Режим трассировщика Недопстимые операции Ошибки адресации

Планировщик
Компонент ядра определяющий следующий процесс на выполнение. Определяет из списка готовых к выполнению задач наиболее подходящую

Вытеснение процесса
Выполняется процесс а, процесс b переходит в статус "готов к выполнению", ядро видит, что его приоритет выше и вызывается планировщик, вытесняющий процесс а.

Синхронизация процессов в ОС
Синхронизация процессов — это задача координации выполнения процессов таким образом, чтобы никакие два процесса не могли иметь доступ к одним и тем же общим данным и ресурсам.

Это особенно необходимо в многопроцессорной системе, когда несколько процессов выполняются вместе, и более чем один процесс пытается получить доступ к одному и тому же общему ресурсу или данным одновременно. Это может привести к несогласованности общих данных. Таким образом, изменение, внесенное одним процессом, не обязательно отражается, когда другие процессы получают доступ к одним и тем же общим данным. Чтобы избежать такого несоответствия данных, процессы должны быть синхронизированы друг с другом.

Разделы программы
Основные элементы критического раздела:

Раздел ввода: это часть процесса, которая решает вступление в конкретный процесс.
Критический раздел: эта часть позволяет одному процессу вводить и изменять общую переменную.
Секция выхода: секция выхода позволяет другому процессу, ожидающему в секции ввода, войти в критические секции. Он также проверяет, что процесс, который завершил свое выполнение, должен быть удален через этот раздел.
Раздел «Остаток»: все остальные части Кодекса, которые не входят в раздел «Критический», «Вход и выход», называются Разделом «Остаток».
Мьютексы
Аппаратное обеспечение синхронизации не простой метод для реализации для всех, поэтому был также введен строгий программный метод, известный как Mutex Locks. При таком подходе в разделе ввода кода получается LOCK для критических ресурсов, используемых внутри критического раздела. В секции выхода эта блокировка снята.

Семафоры
Алгоритм или решение проблемы критической секции Семафор — это просто переменная, которая неотрицательна и разделена между потоками. Это еще один алгоритм или решение проблемы критического сечения. Это механизм сигнализации и поток, ожидающий семафор, который может быть передан другим потоком.

Он использует две атомарные операции:

ожидание
сигнал для синхронизации процесса
Критические секции
Критическая секция — это сегмент кода, который может быть доступен при обработке сигнала в определенный момент времени. Раздел состоит из общих ресурсов данных, которые должны быть доступны для других процессов.

Запись в критическую секцию обрабатывается функцией wait () и представляется как P ().
Выход из критической секции контролируется функцией signal (), представленной как V (). В критическом разделе может быть выполнен только один процесс. Другие процессы, ожидающие выполнения своего критического раздела, должны ждать, пока текущий процесс завершит свое выполнение.
В критическом разделе должны соблюдаться все три правила:

Взаимное исключение
Прогресс
Ожидание привязки
RabbitMQ
RabbitMQ - брокер сообщений с открытым исходным кодом Работу можно описать следующим образом: Издатель отправляет сообщение определенному обменнику Обменник маршрутизирует его в одну или несколько очередей в соответтвии с правилами между ним и очередью Очередь хранит хранит ссылку на сообщение. Само сообщение хранится в оперативной памяти или на диске. Когда потребидель готов получить сообщение из очереди на сервер создает копию соодщения по ссылке и отправляет Потребитель получает сообщение и отправляет брокеру подтверждение. Брокер, получив подтверждение, удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти или с диска.

MQ - Message Queue image


Docker - по с открытым исходным кодом, применяемое для разработки, тестирования, доставки и запуска веб-приложения в средах с поддержкой контейнеризации. нужен для более эфективного использования систему ресурсов , быстрого развертывания готовых программных продуктов, а также для их масштабирования и переноса в другие вторники с гарантированным сохранением стабильной работы.
Doker-demon - сервер контейнеров, входящих в состав программных средств Docker, Управляет Doker-объектами. Doker-client(CLI) - интерфейс взаимодействия пользователя с Doker-demon. Doker-образ файл, включающий зависимости, сведения, конфигурацию для дальнейшего развертывания и инициализации контейнера. Doker-файл - описание правид по сборке образа, в котором первая строка указывает на юазовый образ. Последующие команды выполняют копирование файлов и кстановку программ для создания определенной среды для разработки Doker-container - легкий автономный исполнемый пакет ПО, который включаает в себя все необходимые для запуска приложения: код, среду выполнения, системные инструменты библиотеки и настрйоки.

Как работает
Пользователь дает команду. Может запускать и удалать контейнеры. Взаимодействие обеспечиается REST API.

При запуске контейнера запускается образ, проверяется его существование. использует существующий или выполняет скачивание с Doker Hub.

Создание контейнера из образа
Разметка файловой системы и добавление слоя для записи.
Создание сетевого интерфейса
Поиск и присвоение ip
Запуск процесса
Захват ввода\вывода приложения.
InfluxDB
БД временных рядов. Системы баз данных предназначенная для обработки информации связанной со временем. У данных есть метка времени

Зачем нужны? При добавлении новыз записей в реляционную бд и при наличии в таблице индексов СУБД будет многократно переиндексировать данные для быстрого и эффективного доступа к ним. Следовательно, со временем производительность снижается, увеличивается нагрузка, что приводит к трудностям при чтении данных.

БД временных рядов оптимизировано для быстрого приема данных. Такие системы используют индексацию данных, объедененных со временем. Следовательно, скорость загрузки не уменьшается со временем и остается стабильной.
 
